<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pixel Neighbourhood & Distance Study</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Space+Grotesk:wght@300;600;700&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #0d0f1a;
    --panel: #141726;
    --border: #252a45;
    --accent: #00e5ff;
    --accent2: #ff4b6e;
    --accent3: #b8ff57;
    --text: #cdd6f4;
    --muted: #6272a4;
    --v0: #1e2235;
    --v1: #2d4a7a;
    --v2: #5c8fd6;
    --v3: #93c5fd;
  }
  * { margin:0; padding:0; box-sizing:border-box; }
  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Space Grotesk', sans-serif;
    min-height: 100vh;
    padding: 24px;
  }
  h1 { font-size: 1.6rem; font-weight: 700; color: var(--accent); letter-spacing: -0.5px; margin-bottom: 4px; }
  .subtitle { color: var(--muted); font-size: 0.85rem; margin-bottom: 20px; }
  .layout { display: flex; gap: 24px; flex-wrap: wrap; align-items: flex-start; }

  /* ── Grid ── */
  .grid-wrap {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 20px;
    flex-shrink: 0;
  }
  .grid-top-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
  }
  .grid-label {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.7rem;
    color: var(--muted);
  }
  #grid-container { position: relative; display: inline-block; }
  #grid {
    display: grid;
    grid-template-columns: repeat(10, 52px);
    grid-template-rows: repeat(10, 52px);
    gap: 3px;
    position: relative;
    z-index: 1;
  }
  /* SVG overlay for animated path lines */
  #path-svg {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 2;
  }

  /* ── Cells ── */
  .cell {
    width: 52px; height: 52px;
    border-radius: 6px;
    display: flex; align-items: center; justify-content: center;
    font-family: 'JetBrains Mono', monospace;
    font-size: 1.1rem;
    font-weight: 700;
    cursor: pointer;
    transition: transform 0.1s, box-shadow 0.1s;
    position: relative;
    border: 2px solid transparent;
    user-select: none;
  }
  .cell:hover { transform: scale(1.08); z-index: 10; }
  .cell[data-v="0"] { background: var(--v0); color: #3d4568; }
  .cell[data-v="1"] { background: var(--v1); color: #7db3f5; }
  .cell[data-v="2"] { background: var(--v2); color: #fff; }
  .cell[data-v="3"] { background: var(--v3); color: #0d1a3a; }

  body.edit-mode .cell { cursor: crosshair; }
  body.edit-mode .cell:hover { transform: scale(1.05); }

  .cell.selected  { border-color: var(--accent);  box-shadow: 0 0 0 3px #00e5ff33; z-index: 20; }
  .cell.selected::after  { content:'★'; position:absolute; font-size:9px; top:2px; right:3px; color:var(--accent); }
  .cell.selected2 { border-color: #f97316; box-shadow: 0 0 0 3px #f9731633; z-index: 20; }
  .cell.selected2::after { content:'◆'; position:absolute; font-size:9px; top:2px; right:3px; color:#f97316; }

  /* Neighbour highlights */
  .cell.n4 { background: #ff4b6e88 !important; border-color: var(--accent2); }
  .cell.n8 { background: #b8ff5766 !important; border-color: var(--accent3); }
  .cell.nm { background: #a78bfa66 !important; border-color: #a78bfa; }

  /* Path step highlights */
  .cell.path-p4 { outline: 3px solid var(--accent2); outline-offset: -3px; }
  .cell.path-p8 { outline: 3px solid var(--accent3); outline-offset: -3px; }
  .cell.path-pm { outline: 3px solid #a78bfa;        outline-offset: -3px; }

  /* Dim cells outside V-set when path mode active */
  .cell.vset-off { opacity: 0.22; transition: opacity 0.2s; }

  /* ── Panels ── */
  .side { flex: 1; min-width: 280px; display: flex; flex-direction: column; gap: 16px; }
  .panel { background: var(--panel); border: 1px solid var(--border); border-radius: 12px; padding: 16px; }
  .panel h2 { font-size: 0.78rem; text-transform: uppercase; letter-spacing: 1.5px; color: var(--muted); margin-bottom: 12px; }

  .legend-item { display:flex; align-items:center; gap:10px; margin-bottom:8px; font-size:0.88rem; }
  .swatch { width:18px; height:18px; border-radius:4px; flex-shrink:0; border:2px solid transparent; }
  .swatch.sel { background:#00e5ff33; border-color:var(--accent); }
  .swatch.n4  { background:#ff4b6e88; border-color:var(--accent2); }
  .swatch.n8  { background:#b8ff5766; border-color:var(--accent3); }
  .swatch.nm  { background:#a78bfa66; border-color:#a78bfa; }

  .info-box {
    background: #0d0f1a; border: 1px solid var(--border); border-radius: 8px;
    padding: 12px; font-family: 'JetBrains Mono', monospace; font-size: 0.82rem;
    line-height: 1.9; color: var(--text); white-space: pre-wrap;
  }
  .info-box span { color: var(--accent); }
  .info-box .r   { color: var(--accent2); }
  .info-box .g   { color: var(--accent3); }
  .info-box .p   { color: #a78bfa; }
  .info-box .or  { color: #f97316; }

  .formula {
    background: #0d0f1a; border-left: 3px solid var(--accent);
    border-radius: 0 8px 8px 0; padding: 10px 14px;
    font-family: 'JetBrains Mono', monospace; font-size: 0.8rem;
    color: var(--text); margin-bottom: 8px; line-height: 1.7;
  }
  .formula .label { color:var(--muted); font-size:0.72rem; display:block; margin-bottom:2px; }

  .dist-table { width:100%; border-collapse:collapse; font-size:0.82rem; }
  .dist-table th { font-family:'JetBrains Mono',monospace; color:var(--muted); font-weight:400; padding:4px 8px; text-align:left; border-bottom:1px solid var(--border); }
  .dist-table td { font-family:'JetBrains Mono',monospace; padding:5px 8px; border-bottom:1px solid #1a1f35; }
  .dist-table td:first-child { color: var(--accent2); }
  .dist-table .d-city  { color: var(--accent); }
  .dist-table .d-chess { color: var(--accent3); }
  .dist-table .d-eu    { color: #a78bfa; }

  .tip { color:var(--muted); font-size:0.78rem; margin-top:10px; font-style:italic; }

  /* ── Generic toggle buttons ── */
  .toggle-row { display:flex; gap:8px; flex-wrap:wrap; margin-bottom:8px; }
  .toggle-btn {
    padding:5px 12px; border-radius:20px; border:2px solid var(--border);
    background:transparent; color:var(--muted);
    font-family:'Space Grotesk',sans-serif; font-size:0.78rem;
    cursor:pointer; transition:all 0.2s;
  }
  .toggle-btn.active-n4 { border-color:var(--accent2); color:var(--accent2); background:#ff4b6e15; }
  .toggle-btn.active-n8 { border-color:var(--accent3); color:var(--accent3); background:#b8ff5715; }
  .toggle-btn.active-nm { border-color:#a78bfa; color:#a78bfa; background:#a78bfa15; }

  /* ── V-set value buttons ── */
  .vset-btn {
    width:38px; height:38px; border-radius:8px; border:2px solid var(--border);
    background:transparent; font-family:'JetBrains Mono',monospace; font-size:1rem;
    font-weight:700; cursor:pointer; transition:all 0.2s; color:var(--muted);
  }
  .vset-btn[data-val="0"].active { background:var(--v0); border-color:#8899cc; color:#8899cc; }
  .vset-btn[data-val="1"].active { background:var(--v1); border-color:#7db3f5; color:#7db3f5; }
  .vset-btn[data-val="2"].active { background:var(--v2); border-color:#fff; color:#fff; }
  .vset-btn[data-val="3"].active { background:var(--v3); border-color:#0d1a3a; color:#0d1a3a; }

  /* ── Path type buttons ── */
  .path-type-btn {
    padding:5px 12px; border-radius:20px; border:2px solid var(--border);
    background:transparent; color:var(--muted);
    font-family:'Space Grotesk',sans-serif; font-size:0.78rem;
    cursor:pointer; transition:all 0.2s;
  }
  .path-type-btn.active-p4 { border-color:var(--accent2); color:var(--accent2); background:#ff4b6e15; }
  .path-type-btn.active-p8 { border-color:var(--accent3); color:var(--accent3); background:#b8ff5715; }
  .path-type-btn.active-pm { border-color:#a78bfa; color:#a78bfa; background:#a78bfa15; }

  /* ── Edit mode ── */
  .edit-btn {
    padding:7px 16px; border-radius:8px; border:2px solid var(--border);
    background:transparent; color:var(--muted);
    font-family:'Space Grotesk',sans-serif; font-size:0.82rem;
    cursor:pointer; transition:all 0.2s; display:flex; align-items:center; gap:7px;
  }
  .edit-btn.active { border-color:#f97316; color:#f97316; background:#f9731615; }
  .edit-btn .dot { width:8px; height:8px; border-radius:50%; background:var(--muted); transition:background 0.2s; }
  .edit-btn.active .dot { background:#f97316; box-shadow:0 0 6px #f97316; }

  .paint-row { display:flex; gap:8px; align-items:center; margin-top:8px; }
  .paint-val-btn {
    width:44px; height:44px; border-radius:8px; border:3px solid transparent;
    font-family:'JetBrains Mono',monospace; font-size:1.1rem; font-weight:700;
    cursor:pointer; transition:all 0.15s;
  }
  .paint-val-btn[data-val="0"] { background:var(--v0); color:#8899cc; }
  .paint-val-btn[data-val="1"] { background:var(--v1); color:#7db3f5; }
  .paint-val-btn[data-val="2"] { background:var(--v2); color:#fff; }
  .paint-val-btn[data-val="3"] { background:var(--v3); color:#0d1a3a; }
  .paint-val-btn.active { border-color:#f97316; box-shadow:0 0 10px #f9731655; transform:scale(1.1); }
  .paint-val-btn:not(.active) { opacity:0.5; }

  .reset-btn {
    padding:5px 14px; border-radius:8px; border:1px solid var(--border);
    background:transparent; color:var(--muted); font-family:'Space Grotesk',sans-serif;
    font-size:0.78rem; cursor:pointer; transition:all 0.2s;
  }
  .reset-btn:hover { border-color:var(--accent2); color:var(--accent2); }

  .shuffle-btn {
    padding:5px 14px; border-radius:8px; border:1px solid var(--border);
    background:transparent; color:#b8ff57; border-color:#b8ff5766;
    font-family:'Space Grotesk',sans-serif; font-size:0.78rem;
    cursor:pointer; transition:all 0.2s;
  }
  .shuffle-btn:hover { border-color:var(--accent3); background:#b8ff5715; box-shadow:0 0 8px #b8ff5733; }
  .shuffle-btn.spin { animation: shuffleSpin 0.4s ease; }
  @keyframes shuffleSpin { 0%{transform:scale(1)} 50%{transform:scale(0.88) rotate(8deg)} 100%{transform:scale(1)} }

  /* Path result callout */
  .path-callout {
    background: #0d0f1a; border: 1px solid var(--border); border-radius: 8px;
    padding: 10px 12px; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem;
    color: var(--text); white-space: pre-wrap; line-height: 1.8; margin-top: 10px;
  }
  .no-path { color: var(--accent2); font-style: italic; }

  @keyframes dashAnim { to { stroke-dashoffset: 0; } }
</style>
</head>
<body>

<h1>Pixel Neighbourhood &amp; Distance Metrics</h1>
<p class="subtitle">
  <span style="color:var(--accent)">★ Click</span> to set pixel P &nbsp;|&nbsp;
  <span style="color:#f97316">◆ Shift+click</span> to set pixel Q &nbsp;|&nbsp;
  Explore neighbours, paths, and distances in the panels →
</p>

<div class="layout">

  <!-- ══════════ GRID ══════════ -->
  <div class="grid-wrap">
    <div class="grid-top-bar">
      <div class="grid-label">col →&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;row ↓</div>
      <button class="shuffle-btn" id="shuffleBtnTop" onclick="shuffleGrid()" style="margin-right:6px;">⚄ Shuffle</button>
      <button class="edit-btn" id="editBtn" onclick="toggleEditMode()">
        <span class="dot"></span> Edit Grid
      </button>
    </div>

    <!-- Paint bar — only shown in edit mode -->
    <div id="paintBar" style="display:none; background:#0d0f1a; border:1px solid var(--border); border-radius:8px; padding:10px 12px; margin-bottom:10px;">
      <div style="font-size:0.72rem; color:var(--muted); font-family:'JetBrains Mono',monospace; margin-bottom:6px;">
        PAINT VALUE — click or drag on cells to draw
      </div>
      <div class="paint-row">
        <button class="paint-val-btn active" data-val="0" onclick="setPaintVal(0)">0</button>
        <button class="paint-val-btn" data-val="1" onclick="setPaintVal(1)">1</button>
        <button class="paint-val-btn" data-val="2" onclick="setPaintVal(2)">2</button>
        <button class="paint-val-btn" data-val="3" onclick="setPaintVal(3)">3</button>
        <button class="reset-btn" onclick="resetGrid()">↺ Reset</button>
        <button class="shuffle-btn" id="shuffleBtn" onclick="shuffleGrid()">⚄ Shuffle</button>
      </div>
    </div>

    <div id="grid-container">
      <div id="grid"></div>
      <svg id="path-svg"></svg>
    </div>
    <p class="tip">↑ Values 0–3 (intensity levels) &nbsp;|&nbsp; Grid is 10×10</p>
  </div>

  <!-- ══════════ SIDE PANELS ══════════ -->
  <div class="side">

    <!-- Selected pixel info -->
    <div class="panel">
      <h2>Selected Pixel (P)</h2>
      <div class="info-box" id="info">Click a cell to select it.</div>
    </div>

    <!-- Neighbour highlight -->
    <div class="panel">
      <h2>Highlight Neighbours of P</h2>
      <div class="toggle-row">
        <button class="toggle-btn" id="btn-n4" onclick="toggleNeigh('n4')">4-Neighbours (N₄)</button>
        <button class="toggle-btn" id="btn-n8" onclick="toggleNeigh('n8')">8-Neighbours (N₈)</button>
        <button class="toggle-btn" id="btn-nm" onclick="toggleNeigh('nm')">m-Neighbours (Nₘ)</button>
      </div>
      <div style="display:flex; flex-direction:column; gap:6px; margin-top:4px;">
        <div class="legend-item"><div class="swatch sel"></div><span>P — selected reference pixel</span></div>
        <div class="legend-item"><div class="swatch n4"></div><span>N₄ — up / down / left / right only</span></div>
        <div class="legend-item"><div class="swatch n8"></div><span>N₈ — all 8 surrounding pixels</span></div>
        <div class="legend-item"><div class="swatch nm"></div><span>Nₘ — diagonal iff no shared 4-neighbour with same value</span></div>
      </div>
    </div>

    <!-- Shortest Path -->
    <div class="panel">
      <h2>Shortest Path  P → Q</h2>

      <div style="font-size:0.82rem; color:var(--muted); margin-bottom:12px; line-height:1.6;">
        The path may only pass through pixels whose value belongs to the chosen <strong style="color:var(--text)">V-set</strong>.
        Both P and Q must be in V for a path to exist.
      </div>

      <!-- V-set selector -->
      <div style="font-family:'JetBrains Mono',monospace; font-size:0.7rem; color:var(--muted); margin-bottom:6px;">
        V-SET — toggle allowed values
      </div>
      <div style="display:flex; gap:8px; margin-bottom:14px;">
        <button class="vset-btn" data-val="0" onclick="toggleVset(0)">0</button>
        <button class="vset-btn" data-val="1" onclick="toggleVset(1)">1</button>
        <button class="vset-btn" data-val="2" onclick="toggleVset(2)">2</button>
        <button class="vset-btn" data-val="3" onclick="toggleVset(3)">3</button>
      </div>

      <!-- Path connectivity type -->
      <div style="font-family:'JetBrains Mono',monospace; font-size:0.7rem; color:var(--muted); margin-bottom:6px;">
        CONNECTIVITY TYPE
      </div>
      <div class="toggle-row" style="margin-bottom:0;">
        <button class="path-type-btn" id="pbtn-p4" onclick="togglePathType('p4')">4-connected</button>
        <button class="path-type-btn" id="pbtn-p8" onclick="togglePathType('p8')">8-connected</button>
        <button class="path-type-btn" id="pbtn-pm" onclick="togglePathType('pm')">m-connected</button>
      </div>

      <div class="path-callout" id="path-info">Select P and Q, choose a V-set and connectivity type.</div>
    </div>

    <!-- Measure distance P↔Q -->
    <div class="panel">
      <h2>Measure Distance  P ↔ Q</h2>
      <div style="font-size:0.82rem; color:var(--muted); margin-bottom:10px;">
        Pure arithmetic distance — independent of the grid values.
      </div>
      <div class="info-box" id="dist-direct">Select two pixels to measure.</div>
    </div>

    <!-- Distance formulas reference -->
    <div class="panel">
      <h2>Distance Formulas</h2>
      <div class="formula">
        <span class="label">City-Block (Manhattan)  D₄</span>
        D₄(p,q) = |x−x'| + |y−y'|
      </div>
      <div class="formula" style="border-color:var(--accent3)">
        <span class="label">Chessboard (Chebyshev)  D₈</span>
        D₈(p,q) = max(|x−x'|, |y−y'|)
      </div>
      <div class="formula" style="border-color:#a78bfa">
        <span class="label">Euclidean  Dₑ</span>
        Dₑ(p,q) = √[ (x−x')² + (y−y')² ]
      </div>
    </div>

    <!-- Distance table from P -->
    <div class="panel">
      <h2>All Distances from P (closest 12)</h2>
      <div style="overflow-x:auto;">
        <table class="dist-table">
          <thead>
            <tr>
              <th>Cell (r,c)</th>
              <th class="d-city">D₄</th>
              <th class="d-chess">D₈</th>
              <th class="d-eu">Dₑ</th>
            </tr>
          </thead>
          <tbody id="dist-body">
            <tr><td colspan="4" style="color:var(--muted);padding:8px;">Select a pixel first.</td></tr>
          </tbody>
        </table>
      </div>
    </div>

  </div><!-- end .side -->
</div><!-- end .layout -->

<script>
// ════════════════════════════════════════════════════════════
//  DATA  — a 10×10 grid of values 0–3
//  Designed so many different neighbourhood / path scenarios
//  arise when students explore it.
// ════════════════════════════════════════════════════════════
const ORIGINAL = [
  [0,1,2,3,2,1,0,1,2,3],
  [1,2,3,2,1,0,1,2,3,2],
  [2,3,0,1,2,3,2,1,0,1],
  [3,2,1,0,3,2,1,0,1,2],
  [0,1,2,3,0,1,2,3,2,1],
  [1,0,3,2,1,2,3,0,1,2],
  [2,1,0,3,2,3,0,1,2,3],
  [3,2,1,0,3,0,1,2,3,0],
  [0,3,2,1,0,1,2,3,0,1],
  [1,0,3,2,1,2,3,0,1,2],
];
// Working mutable copy
const DATA = ORIGINAL.map(row => [...row]);

// ════════════════════════════════════════════════════════════
//  STATE
// ════════════════════════════════════════════════════════════
let selected  = null;       // pixel P  {r, c}
let selected2 = null;       // pixel Q  {r, c}
let neighMode = null;       // 'n4' | 'n8' | 'nm'
let pathType  = null;       // 'p4' | 'p8' | 'pm'
let vset      = new Set();  // allowed values for path traversal
let editMode  = false;
let paintVal  = 0;
let isPainting = false;

// ════════════════════════════════════════════════════════════
//  BUILD GRID DOM
// ════════════════════════════════════════════════════════════
const gridEl = document.getElementById('grid');

function buildGrid() {
  gridEl.innerHTML = '';
  for (let r = 0; r < 10; r++) {
    for (let c = 0; c < 10; c++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.r = r;
      cell.dataset.c = c;
      cell.dataset.v = DATA[r][c];
      cell.textContent = DATA[r][c];
      cell.title = `(row ${r}, col ${c})  value = ${DATA[r][c]}`;

      cell.addEventListener('mousedown', (e) => {
        if (editMode) {
          // In edit mode: paint on click
          e.preventDefault();
          isPainting = true;
          paintCell(r, c);
        } else if (e.shiftKey) {
          // Shift+click → set Q (don't allow same cell as P)
          if (!(selected && selected.r === r && selected.c === c))
            selected2 = {r, c};
          render();
        } else {
          // Normal click → set P
          selected = {r, c};
          // If Q was same cell, clear it
          if (selected2 && selected2.r === r && selected2.c === c)
            selected2 = null;
          render();
        }
      });

      cell.addEventListener('mouseenter', () => {
        // Support drag-painting
        if (editMode && isPainting) paintCell(r, c);
      });

      gridEl.appendChild(cell);
    }
  }
  // Stop painting when mouse is released anywhere
  document.addEventListener('mouseup', () => { isPainting = false; });
}

function getCell(r, c) {
  return gridEl.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
}

function refreshCellDOM(r, c) {
  const el = getCell(r, c);
  if (!el) return;
  el.dataset.v = DATA[r][c];
  el.textContent = DATA[r][c];
  el.title = `(row ${r}, col ${c})  value = ${DATA[r][c]}`;
}

// ════════════════════════════════════════════════════════════
//  EDIT MODE
// ════════════════════════════════════════════════════════════
function toggleEditMode() {
  editMode = !editMode;
  document.body.classList.toggle('edit-mode', editMode);
  document.getElementById('editBtn').classList.toggle('active', editMode);
  document.getElementById('paintBar').style.display = editMode ? 'block' : 'none';
  if (editMode) {
    // Clear selections while editing to avoid stale highlights
    selected = null; selected2 = null;
    render();
  }
}

function setPaintVal(v) {
  paintVal = v;
  document.querySelectorAll('.paint-val-btn').forEach(b => {
    b.classList.toggle('active', parseInt(b.dataset.val) === v);
  });
}

function paintCell(r, c) {
  if (DATA[r][c] === paintVal) return; // nothing to change
  DATA[r][c] = paintVal;
  refreshCellDOM(r, c);
  render(); // live-update any active paths/highlights
}

function resetGrid() {
  for (let r = 0; r < 10; r++)
    for (let c = 0; c < 10; c++) {
      DATA[r][c] = ORIGINAL[r][c];
      refreshCellDOM(r, c);
    }
  render();
}

// ════════════════════════════════════════════════════════════
//  V-SET  &  PATH TYPE TOGGLES
// ════════════════════════════════════════════════════════════
function toggleVset(v) {
  if (vset.has(v)) vset.delete(v); else vset.add(v);
  document.querySelectorAll('.vset-btn').forEach(b => {
    b.classList.toggle('active', vset.has(parseInt(b.dataset.val)));
  });
  render();
}

function togglePathType(t) {
  pathType = (pathType === t) ? null : t;
  ['p4','p8','pm'].forEach(pt => {
    const btn = document.getElementById('pbtn-' + pt);
    btn.className = 'path-type-btn' + (pathType === pt ? ` active-${pt}` : '');
  });
  render();
}

function toggleNeigh(m) {
  neighMode = (neighMode === m) ? null : m;
  render();
}

// ════════════════════════════════════════════════════════════
//  NEIGHBOUR LOGIC
// ════════════════════════════════════════════════════════════
function inBounds(r, c) { return r >= 0 && r < 10 && c >= 0 && c < 10; }

function getNeighbours(r, c, type) {
  const n4 = [[r-1,c],[r+1,c],[r,c-1],[r,c+1]].filter(([nr,nc]) => inBounds(nr,nc));
  if (type === 'n4') return n4;

  const diag = [[r-1,c-1],[r-1,c+1],[r+1,c-1],[r+1,c+1]].filter(([nr,nc]) => inBounds(nr,nc));
  if (type === 'n8') return [...n4, ...diag];

  if (type === 'nm') {
    // m-neighbours: 4-neighbours with same value PLUS
    // diagonal neighbours with same value that share NO 4-neighbour also having same value
    const v = DATA[r][c];
    const mN = [];
    n4.forEach(([nr,nc]) => { if (DATA[nr][nc] === v) mN.push([nr,nc]); });
    diag.forEach(([dr,dc]) => {
      if (DATA[dr][dc] !== v) return;
      const N4q = [[dr-1,dc],[dr+1,dc],[dr,dc-1],[dr,dc+1]].filter(([nr,nc]) => inBounds(nr,nc));
      const shared = n4.filter(([pr,pc]) =>
        N4q.some(([qr,qc]) => qr===pr && qc===pc) && DATA[pr][pc]===v
      );
      if (shared.length === 0) mN.push([dr,dc]);
    });
    return mN;
  }
  return [];
}

// ════════════════════════════════════════════════════════════
//  BFS SHORTEST PATH
//  conn = '4' | '8' | 'm'
//  allowedVset = Set of allowed pixel values
// ════════════════════════════════════════════════════════════
function bfsPath(sr, sc, er, ec, conn, allowedVset) {
  // Both endpoints must be in the V-set
  if (!allowedVset.has(DATA[sr][sc]) || !allowedVset.has(DATA[er][ec])) return null;

  const key = (r, c) => r * 10 + c;
  const visited = new Array(100).fill(false);
  const parent  = new Array(100).fill(-1);
  const queue   = [[sr, sc]];
  visited[key(sr, sc)] = true;

  while (queue.length) {
    const [r, c] = queue.shift();
    if (r === er && c === ec) {
      // Reconstruct path backwards
      const path = [];
      let cur = key(er, ec);
      while (cur !== -1) {
        path.push([Math.floor(cur / 10), cur % 10]);
        cur = parent[cur];
      }
      return path.reverse();
    }

    // Build candidate neighbours based on connectivity type
    let nbrs;
    if (conn === '4') {
      nbrs = [[r-1,c],[r+1,c],[r,c-1],[r,c+1]];
    } else if (conn === '8') {
      nbrs = [[r-1,c],[r+1,c],[r,c-1],[r,c+1],
               [r-1,c-1],[r-1,c+1],[r+1,c-1],[r+1,c+1]];
    } else {
      // m-connectivity: same rule as m-neighbours, applied locally
      const v = DATA[r][c];
      const n4here = [[r-1,c],[r+1,c],[r,c-1],[r,c+1]].filter(([nr,nc]) => inBounds(nr,nc));
      nbrs = [...n4here]; // start with 4-neighbours
      [[r-1,c-1],[r-1,c+1],[r+1,c-1],[r+1,c+1]].forEach(([dr,dc]) => {
        if (!inBounds(dr,dc) || DATA[dr][dc] !== v) return;
        const N4q = [[dr-1,dc],[dr+1,dc],[dr,dc-1],[dr,dc+1]].filter(([nr,nc]) => inBounds(nr,nc));
        const shared = n4here.filter(([pr,pc]) =>
          N4q.some(([qr,qc]) => qr===pr && qc===pc) && DATA[pr][pc]===v
        );
        if (shared.length === 0) nbrs.push([dr,dc]);
      });
    }

    for (const [nr, nc] of nbrs) {
      if (!inBounds(nr, nc)) continue;
      if (!allowedVset.has(DATA[nr][nc])) continue; // must be in V-set
      const k = key(nr, nc);
      if (!visited[k]) {
        visited[k] = true;
        parent[k] = key(r, c);
        queue.push([nr, nc]);
      }
    }
  }
  return null; // no path found
}

// ════════════════════════════════════════════════════════════
//  SVG PATH ANIMATION
// ════════════════════════════════════════════════════════════
function drawPathSVG(path, strokeColor) {
  const svg = document.getElementById('path-svg');
  svg.innerHTML = '';
  if (!path || path.length < 2) return;

  // Cell stride = cell size (52) + gap (3) = 55px; cell centre at +26
  const stride = 55, half = 26;
  const pts = path.map(([r,c]) => [c * stride + half, r * stride + half]);

  // Main animated line
  const poly = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
  poly.setAttribute('points', pts.map(p => p.join(',')).join(' '));
  poly.setAttribute('fill', 'none');
  poly.setAttribute('stroke', strokeColor);
  poly.setAttribute('stroke-width', '3.5');
  poly.setAttribute('stroke-linecap', 'round');
  poly.setAttribute('stroke-linejoin', 'round');
  poly.setAttribute('opacity', '0.9');

  // Compute total path length for dash animation
  const totalLen = pts.reduce((acc, [x,y], i) => {
    if (i === 0) return 0;
    const [px, py] = pts[i-1];
    return acc + Math.hypot(x-px, y-py);
  }, 0);
  poly.setAttribute('stroke-dasharray', totalLen);
  poly.setAttribute('stroke-dashoffset', totalLen);
  poly.style.animation = 'dashAnim 0.55s ease forwards';
  svg.appendChild(poly);

  // Small dots on intermediate steps (not start/end)
  path.forEach(([r,c], i) => {
    if (i === 0 || i === path.length - 1) return;
    const [x,y] = [c*stride+half, r*stride+half];
    const circ = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circ.setAttribute('cx', x); circ.setAttribute('cy', y);
    circ.setAttribute('r', '4');
    circ.setAttribute('fill', strokeColor);
    circ.setAttribute('opacity', '0.65');
    svg.appendChild(circ);
  });
}

// ════════════════════════════════════════════════════════════
//  MAIN RENDER — called on every state change
// ════════════════════════════════════════════════════════════
function render() {
  // 1. Reset all cell classes (keep data-v from DATA)
  document.querySelectorAll('.cell').forEach(el => {
    const r = parseInt(el.dataset.r), c = parseInt(el.dataset.c);
    el.className = 'cell';
    el.dataset.v = DATA[r][c]; // keep in sync with mutable DATA
  });

  // 2. Clear SVG overlay
  document.getElementById('path-svg').innerHTML = '';

  // 3. Sync neighbour button states
  ['n4','n8','nm'].forEach(m => {
    const btn = document.getElementById('btn-' + m);
    if (btn) btn.className = 'toggle-btn' + (neighMode === m ? ` active-${m}` : '');
  });

  // 4. If nothing selected, show placeholder text and return
  if (!selected) {
    document.getElementById('info').textContent = 'Click a cell to select it.';
    document.getElementById('dist-direct').textContent = 'Select two pixels to measure.';
    updateDistTable(null);
    updatePathInfo(null, null);
    return;
  }

  const {r, c} = selected;

  // 5. Mark P and Q
  getCell(r, c).classList.add('selected');
  if (selected2 && !(selected2.r === r && selected2.c === c))
    getCell(selected2.r, selected2.c).classList.add('selected2');

  // 6. Neighbour highlights
  if (neighMode) {
    getNeighbours(r, c, neighMode).forEach(([nr,nc]) =>
      getCell(nr,nc).classList.add(neighMode)
    );
  }

  // 7. Info box for P
  const v = DATA[r][c];
  document.getElementById('info').innerHTML =
    `Position: <span>(row ${r}, col ${c})</span>\nValue:    <span>${v}</span>\n` +
    `N₄ count: <span class="r">${getNeighbours(r,c,'n4').length}</span>\n` +
    `N₈ count: <span class="g">${getNeighbours(r,c,'n8').length}</span>\n` +
    `Nₘ count: <span class="p">${getNeighbours(r,c,'nm').length}</span>`;

  // 8. Direct P↔Q distance
  updateDirectDistance();

  // 9. Distance table from P
  updateDistTable(selected);

  // 10. Shortest path (only if P, Q, pathType, and non-empty V-set all present)
  if (selected && selected2 && pathType && vset.size > 0) {
    const conn      = pathType === 'p4' ? '4' : pathType === 'p8' ? '8' : 'm';
    const pathColor = pathType === 'p4' ? '#ff4b6e' : pathType === 'p8' ? '#b8ff57' : '#a78bfa';
    const pathCls   = pathType === 'p4' ? 'path-p4' : pathType === 'p8' ? 'path-p8' : 'path-pm';

    const path = bfsPath(selected.r, selected.c, selected2.r, selected2.c, conn, vset);

    // Dim all cells NOT in V-set
    document.querySelectorAll('.cell').forEach(el => {
      if (!vset.has(parseInt(el.dataset.v))) el.classList.add('vset-off');
    });

    if (path) {
      // Un-dim and highlight path cells
      path.forEach(([pr,pc]) => {
        const el = getCell(pr,pc);
        el.classList.remove('vset-off');
        el.classList.add(pathCls);
      });
      drawPathSVG(path, pathColor);
    }

    updatePathInfo(path, conn);
  } else {
    updatePathInfo(null, null);
  }
}

// ════════════════════════════════════════════════════════════
//  PATH INFO CALLOUT
// ════════════════════════════════════════════════════════════
function updatePathInfo(path, conn) {
  const box = document.getElementById('path-info');

  if (!selected || !selected2) {
    box.innerHTML = 'Select P and Q, choose a V-set and connectivity type.';
    return;
  }
  if (!pathType) {
    box.innerHTML = 'Choose a connectivity type above to compute the path.';
    return;
  }
  if (vset.size === 0) {
    box.innerHTML = '<span class="no-path">V-set is empty — activate at least one value.</span>';
    return;
  }

  const pv = DATA[selected.r][selected.c];
  const qv = DATA[selected2.r][selected2.c];

  if (!vset.has(pv) || !vset.has(qv)) {
    box.innerHTML =
      `<span class="no-path">P [${pv}] or Q [${qv}] is not in V = {${[...vset].sort().join(', ')}}.\nBoth endpoints must belong to V.</span>`;
    return;
  }

  if (!path) {
    box.innerHTML =
      `<span class="no-path">No ${conn}-connected path from P to Q through V = {${[...vset].sort().join(', ')}}.\nTry widening the V-set or changing connectivity.</span>`;
    return;
  }

  const connLabel = conn==='4' ? '4-connected' : conn==='8' ? '8-connected' : 'm-connected';
  const cls = pathType==='p4' ? 'r' : pathType==='p8' ? 'g' : 'p';
  box.innerHTML =
    `Connectivity: <span class="${cls}">${connLabel}</span>\n` +
    `V-set:  {${[...vset].sort().join(', ')}}\n` +
    `Length: <span>${path.length - 1}</span> steps  (${path.length} pixels)\n` +
    `Sequence:\n  ${path.map(([pr,pc]) => `(${pr},${pc})[${DATA[pr][pc]}]`).join(' →\n  ')}`;
}

// ════════════════════════════════════════════════════════════
//  DIRECT DISTANCE DISPLAY
// ════════════════════════════════════════════════════════════
function updateDirectDistance() {
  const box = document.getElementById('dist-direct');
  if (!selected) { box.textContent = 'Select two pixels to measure.'; return; }
  if (!selected2) {
    box.innerHTML =
      `P = <span>(row ${selected.r}, col ${selected.c})</span>  [${DATA[selected.r][selected.c]}]\n` +
      `<span style="color:var(--muted)">Shift+click any cell to set Q.</span>`;
    return;
  }
  const {r:r1,c:c1} = selected, {r:r2,c:c2} = selected2;
  const d4 = Math.abs(r1-r2) + Math.abs(c1-c2);
  const d8 = Math.max(Math.abs(r1-r2), Math.abs(c1-c2));
  const de = Math.sqrt((r1-r2)**2 + (c1-c2)**2);
  box.innerHTML =
    `P = <span>(row ${r1}, col ${c1})</span>  [${DATA[r1][c1]}]\n` +
    `Q = <span class="or">(row ${r2}, col ${c2})</span>  [${DATA[r2][c2]}]\n\n` +
    `D₄ (Manhattan)  = <span class="r">${d4}</span>\n` +
    `D₈ (Chessboard) = <span class="g">${d8}</span>\n` +
    `Dₑ (Euclidean)  = <span class="p">${de.toFixed(4)}</span>`;
}

// ════════════════════════════════════════════════════════════
//  DISTANCE TABLE  (closest 12 cells from P)
// ════════════════════════════════════════════════════════════
function updateDistTable(sel) {
  const tbody = document.getElementById('dist-body');
  if (!sel) {
    tbody.innerHTML = '<tr><td colspan="4" style="color:var(--muted);padding:8px;">Select a pixel first.</td></tr>';
    return;
  }
  const {r:sr, c:sc} = sel;
  const targets = [];
  for (let r=0; r<10; r++) for (let c=0; c<10; c++) {
    if (r===sr && c===sc) continue;
    targets.push({ r, c,
      d4: Math.abs(r-sr)+Math.abs(c-sc),
      d8: Math.max(Math.abs(r-sr),Math.abs(c-sc)),
      de: Math.sqrt((r-sr)**2+(c-sc)**2)
    });
  }
  targets.sort((a,b) => a.de - b.de);
  tbody.innerHTML = targets.slice(0,12).map(({r,c,d4,d8,de}) =>
    `<tr>
      <td>(${r},${c}) <span style="color:var(--muted);font-size:0.72rem;">[${DATA[r][c]}]</span></td>
      <td class="d-city">${d4}</td>
      <td class="d-chess">${d8}</td>
      <td class="d-eu">${de.toFixed(2)}</td>
    </tr>`
  ).join('');
}

// ════════════════════════════════════════════════════════════
//  SHUFFLE  — random grid with pedagogically useful structure
// ════════════════════════════════════════════════════════════
function shuffleGrid() {
  // Conditions for a "sensible" grid:
  //   1. Each value 0–3 appears roughly equally (±2) per row and column
  //   2. No value repeats more than 3 times in any row or column
  //   3. At least two connected regions of the same value exist (guarantees
  //      interesting paths and neighbour counts, avoids fully isolated pixels)
  //   4. Diagonal pairs of same value exist (so m-neighbours behave interestingly)

  const MAX_TRIES = 800;

  function attempt() {
    const grid = [];
    for (let r = 0; r < 10; r++) {
      const row = [];
      for (let c = 0; c < 10; c++) row.push(Math.floor(Math.random() * 4));
      grid.push(row);
    }
    return grid;
  }

  function score(grid) {
    let s = 0;

    // Count value frequencies per row and column
    for (let r = 0; r < 10; r++) {
      const freq = [0,0,0,0];
      grid[r].forEach(v => freq[v]++);
      // Penalise if any value appears more than 4 times or less than 1 time in a row
      freq.forEach(f => { if (f > 4) s -= 30; if (f === 0) s -= 15; });
      // Penalise runs of 3+ identical values in a row
      for (let c = 0; c < 8; c++)
        if (grid[r][c]===grid[r][c+1] && grid[r][c+1]===grid[r][c+2]) s -= 10;
    }
    for (let c = 0; c < 10; c++) {
      const freq = [0,0,0,0];
      for (let r = 0; r < 10; r++) freq[grid[r][c]]++;
      freq.forEach(f => { if (f > 4) s -= 30; if (f === 0) s -= 15; });
      for (let r = 0; r < 8; r++)
        if (grid[r][c]===grid[r+1][c] && grid[r+1][c]===grid[r+2][c]) s -= 10;
    }

    // Reward 4-connected same-value neighbours (creates connected regions)
    let n4pairs = 0;
    for (let r = 0; r < 10; r++)
      for (let c = 0; c < 10; c++) {
        if (r+1 < 10 && grid[r][c]===grid[r+1][c]) n4pairs++;
        if (c+1 < 10 && grid[r][c]===grid[r][c+1]) n4pairs++;
      }
    s += n4pairs * 3; // want healthy connectivity

    // Reward diagonal same-value pairs with no shared 4-neighbour (interesting m-neighbours)
    let mPairs = 0;
    for (let r = 0; r < 9; r++)
      for (let c = 0; c < 9; c++) {
        const v = grid[r][c];
        [[r+1,c+1],[r+1,c-1]].forEach(([dr,dc]) => {
          if (dr<0||dr>9||dc<0||dc>9) return;
          if (grid[dr][dc] !== v) return;
          // check no shared 4-neighbour with same value
          const n4p = [[r-1,c],[r+1,c],[r,c-1],[r,c+1]];
          const n4q = [[dr-1,dc],[dr+1,dc],[dr,dc-1],[dr,dc+1]];
          const shared = n4p.filter(([pr,pc]) =>
            pr>=0&&pr<10&&pc>=0&&pc<10 &&
            n4q.some(([qr,qc])=>qr===pr&&qc===pc) && grid[pr][pc]===v
          );
          if (shared.length === 0) mPairs++;
        });
      }
    s += mPairs * 2;

    // Reward existence of at least one long 4-connected path for each value
    for (let v = 0; v < 4; v++) {
      let maxRegion = 0;
      const visited = Array.from({length:10},()=>new Array(10).fill(false));
      for (let r=0;r<10;r++) for (let c=0;c<10;c++) {
        if (visited[r][c]||grid[r][c]!==v) continue;
        // BFS flood fill
        const q=[[r,c]]; visited[r][c]=true; let sz=0;
        while(q.length){const[nr,nc]=q.shift();sz++;[[nr-1,nc],[nr+1,nc],[nr,nc-1],[nr,nc+1]].forEach(([a,b])=>{if(a>=0&&a<10&&b>=0&&b<10&&!visited[a][b]&&grid[a][b]===v){visited[a][b]=true;q.push([a,b]);}});}
        maxRegion = Math.max(maxRegion, sz);
      }
      s += maxRegion * 2; // reward large connected regions per value
    }

    return s;
  }

  // Run a mini hill-climb: take best of MAX_TRIES attempts
  let bestGrid = null, bestScore = -Infinity;
  for (let t = 0; t < MAX_TRIES; t++) {
    const g = attempt();
    const sc2 = score(g);
    if (sc2 > bestScore) { bestScore = sc2; bestGrid = g; }
  }

  // Apply to DATA
  for (let r = 0; r < 10; r++)
    for (let c = 0; c < 10; c++) {
      DATA[r][c] = bestGrid[r][c];
      refreshCellDOM(r, c);
    }

  // Animate buttons
  ['shuffleBtn','shuffleBtnTop'].forEach(id => {
    const el = document.getElementById(id);
    if (el) { el.classList.remove('spin'); void el.offsetWidth; el.classList.add('spin'); }
  });

  // Clear selections & re-render
  selected = null; selected2 = null;
  render();
}

// ════════════════════════════════════════════════════════════
//  INIT
// ════════════════════════════════════════════════════════════
buildGrid();
selected = {r:4, c:4};   // start with a central cell selected
render();
</script>
</body>
</html>
